---
title: "Overview"
output: rmarkdown::html_vignette
bibliography: "bibliography.bib"
vignette: >
  %\VignetteIndexEntry{Overview}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 4,
  fig.height = 4,
  fig.align = "center"
)
```

```{r setup}
library(rasenna)

# example data, see ?capra for details
data(capra)

# column 'timestamp' as POSIXct
capra[["timestamp"]] <- as.POSIXct(
  strptime(
    capra[["timestamp"]], 
    format = "%Y-%m-%d %H:%M:%S", 
    tz = "UTC"
  )
)
```

The functions `distance()`, `bearing()`, and `turning_angle()` wrap C++ functions 
that calculate the Euclidean distance, bearing, and turning angles between relocations, respectively.
The function `annotate()` wraps the three functions above.

```{r annotate}
capra <- annotate(capra)
head(capra)
```

## Handling outliers

```{r outliers}
# speed in m/s, they are all reasonable: no outliers
range(na.omit(capra)$speed, na.rm = TRUE)

# plot to see if some high speeds and high turning angles
with(
  na.omit(capra),
  plot(speed, turningAngle, xlab = "Speed (km/h)", ylab = expression(theta))
)
plot(capra$x / 1e3, capra$y / 1e3, xlab = "Easting (km)", ylab = "Northing (km)")
```

## Resample telemetry data

Many analyses using telemetry data assume that the fixes have been sampled at the same temporal resolution, i.e. at a constant time interval.
The `resample()` function re-sample telemetry data to force this assumption.
Re-sampling is done by removing fixes that are closer in time than an user-specified time interval (see _freq_ and _low_ in `?resample()`).
When a fix is removed, the time interval between fixes is re-calculated.
Additionally, fixes that are apart more than a given time interval (see _high_ in `?resample()`) are kept, but they are assigned different _ID_s to indicate they belong to different tracks and should not be analyzed as part of the same consecutive trajectory.

```{r resample}
summary(capra$lagHour)

capra <- resample(
  capra,
  ts_col = "timestamp", # name of column with time and date
  freq = 3,             # wanted frequency
  units = "hours"       # units of the wanted frequency
)
capra <- capra[capra$ID %in% which(table(capra$ID) > 100), ]
pal <- hcl.colors(length(unique(capra$ID)), "Dark 3", alpha = .5)
plot(
  capra$x, capra$y,
  col = pal[match(capra$ID, cbind(unique(capra$ID), pal))],
  pch = 3, cex = 1.5,

)
i <- 1
for (id in unique(capra$ID)) {
  track <- subset(capra, ID == id)
  lines(track$x, track$y, col = pal[i], lwd = 1.5)
  i <- i + 1
}
```


## Test for serial correlation of direction movement

Telemetry data that is at high temporal resolution may violate the assumption of independence of contiguous fixes.
This can be detected by assessing the correlation between contiguous fixes [@moorcroft2013mechanistic].

```{r direction}
cor_test_direction(capra[capra$ID == unique(capra$ID)[1], ])

pvalue_autocor <- sapply(
  unique(capra$ID), \(i) {
    cor_test_direction(
      capra[capra[["ID"]] == i, ], graph = FALSE
    )$p.value
  }
)
pvalue_autocor

# retain only tracks without serial correlation
capra <- capra[capra$ID %in% unique(capra$ID)[pvalue_autocor > 0.05], ]
```
